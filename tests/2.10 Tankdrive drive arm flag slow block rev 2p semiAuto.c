#pragma config(Hubs,  S1, HTMotor,  HTServo,  HTMotor,  none)
#pragma config(Sensor, S3,     Gyro,           sensorAnalogInactive)
#pragma config(Motor,  motorA,          blockMotor,    tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     motorRight,    tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     motorFlag,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     motorLeft,     tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     motorHang,     tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C2_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "joystickdriver.c"
#include "hitechnic-gyro.h"

// Encoder rotation = 1024


// Buttons:
#define button1   0x01
#define button2   0x02
#define button3   0x04
#define button4   0x08
#define button5   0x10
#define button6   0x20
#define button7   0x40
#define button8   0x80
#define button9  0x100
#define button10 0x200


//Joystick Control Setup:


int joyHangUp = 8;			//Hanging Arm Up
int joyHangDown = 7;		//Hanging Arm Down

int joyFlagUp = 2;			//Flag Up
int joyFlagDown = 3;

int joySlow = 5;				//Slow Driving Mode
int joySuperSlow = 6; 	//Super Slow Driving Mode

int joyBlockUp = 1;
int joyBlockDown = 4;

int joyStartEndgameL = 9;
int joyStartEndgameR = 10;
int joyStopEndgame = 2;

// Control Variables

int slowSpeed = 3;
int superSlowSpeed = 6;
int slowestSpeed = 10;

bool drivingOn = true;

int defaultMovementSpeed = 50;
int turnSpeed = 30;

float rotSpeed = 0;
float heading = 0;


//Scales joysticks on Log scale for precise slow movement
const bool bLogarithmicScale = true;
const bool kMaximumPowerLevel = 100;  // Adjust to set max power level to be used.


int scaleJoystick(int &nJoy1, int nMaxValue = kMaximumPowerLevel)
{
	//
	// This function scales the joystick settings to the appropriate range for
	// controlling a NXT motor.
	//
	// Joystick values range from -128 to +127.
	// Speed/power settings for NXT motors range from -100 to +100
	//
	// The physical range of motion of a joystick is quite small and it is sometimes
	// hard to control slow speeds. So another capability of this program to apply
	// a "logarithmic" scale to the joystick settings.
	//
	static const int nLogScale[17] =
	{
		0,   5,   9,   10,
		12,  15,  18,  24,
		30,  36,  43,  50,
		60,  72,  85, 100,
		100
	};
	int nScaled;

	nScaled = nJoy1;
	if (bLogarithmicScale)
	{
		nScaled /= 8;
		if (nScaled >= 0)
			nScaled = nLogScale[nScaled];
		else
			nScaled = - nLogScale[ - nScaled];
	}
	nScaled *= nMaxValue;
	nScaled /= 100;
	return nScaled;
}



void SetMotors(int setPowLeft, int setPowRight)
{
	//if (setPowLeft > motor[motorLeft]){
	//	motor[motorLeft]=motor[motorLeft]+1;
	//}
	//else if (setPowLeft < motor[motorLeft]){
	//	motor[motorLeft]=motor[motorLeft]-1;
	//}

	//if (setPowRight > motor[motorRight]){
	//	motor[motorRight]=motor[motorRight]+1;
	//}
	//else if (setPowRight < motor[motorRight]){
	//	motor[motorRight]=motor[motorRight]-1;
	//}
	motor[motorRight] =  setPowRight;
	motor[motorLeft]  =  setPowLeft;
}


int slowMode(int slow, int superSlow)
{
	if (slow == 1){
		if (superSlow == 1){
			return slowestSpeed;
		}
		else {
			return slowSpeed;
		}
	}

	if (superSlow == 1){
		return superSlowSpeed;
	}

	return 1;
}


//The Drive
void Tank(int y1, int y2)
{


	int powLeft  = scaleJoystick(y1)/slowMode(joy1Btn(joySlow),joy1Btn(joySuperSlow))*1.0;   // Left  hand joystick, y value.
	int powRight = scaleJoystick(y2)/slowMode(joy1Btn(joySlow),joy1Btn(joySuperSlow))*1.0;   // Right hand joystick, y value.

	SetMotors(powLeft, powRight);
}




//Hanging Motor
void Hang(int up, int down)
{
	if (up==1)
	{
		motor[motorHang] = 100;
	}
	else if (down==1)
	{
		motor[motorHang] = -100;
	}
	else
	{
		motor[motorHang] = 0;
	}
}



void Flag(int up, int down)
{
	if (up==1)
	{
		motor[motorFlag] = 100;
	}
	else if (down==1)
	{
		motor[motorFlag] = -100;
	}
	else
	{
		motor[motorFlag] = 0;
	}
}

task moveBlockMotorUp()
{
	motor[blockMotor] = 30;
	while(nMotorEncoder[blockMotor] <= 130){}
	motor[blockMotor] = 0;
}

task moveBlockMotorDown()
{
	motor[blockMotor] = -30;
	while(nMotorEncoder[blockMotor] >= 50){}
	motor[blockMotor] = 0;
}

void Block(int up, int down)
{
	if (up == 1){
		StopTask(moveBlockMotorDown);
		StartTask(moveBlockMotorUp);
	}
	else if (down == 1){
		StopTask(moveBlockMotorUp);
		StartTask(moveBlockMotorDown);
	}
}


task updateGyro(){
	time1[T1] = 0;

	while (true)
	{
		// Wait until 20ms has passed
		while (time1[T1] < 20){
			wait1Msec(1);
		}

		// Reset the timer
		time1[T1]=0;

		// Read the current rotation speed
		rotSpeed = HTGYROreadRot(Gyro);

		// Calculate the new heading by adding the amount of degrees
		// we've turned in the last 20ms
		// If our current rate of rotation is 100 degrees/second,
		// then we will have turned 100 * (20/1000) = 2 degrees since
		// the last time we measured.
		heading += rotSpeed * 0.02;
	}

}


int sign(int num)
{
	if (num<0){ return -1;}
	else { return 1;}
}

int inchesToEncoder(int inches)
{
	// Returns encoder value from inches
	// Encoder Rotation 1024, wheel circumference = 14.92256, encoders/inch = 86.9198195873
	return inches * 107.75;
}

void resetHeading(){
	heading = 0;
}

void resetEncoders()
{
	nMotorEncoder[motorRight] = 0;
	nMotorEncoder[motorLeft] = 0;
}

int averageEncoders()
{
	return ((nMotorEncoder[motorRight] + nMotorEncoder[motorLeft])/2);
}


int turningEncoders(int dir)
{
	return (dir*(nMotorEncoder[motorRight]*-1 + nMotorEncoder[motorLeft])/2);
}

int moveStraight(int distance, int inchesOrEncoders = true, int speed = defaultMovementSpeed)
{
	resetEncoders();

	int encoderDistance = 0;

	if(inchesOrEncoders){
		encoderDistance = inchesToEncoder(distance);
	}
	else {
		encoderDistance = distance;
	}

	if (distance > 0){
		SetMotors(speed,speed);
		while (averageEncoders() < encoderDistance){
			wait1Msec(3);
		}
	}
	else{
		SetMotors(-speed,-speed);
		while (averageEncoders() > encoderDistance){
			wait1Msec(3);
		}
	}


	SetMotors(0,0);

	return averageEncoders();
}



void turnDegrees(int deg)
{
	resetHeading();

	SetMotors(turnSpeed*sign(deg),turnSpeed*sign(deg)*-1);

	if (deg > 0){
		while (heading < deg){
			wait1Msec(3);
		}
	}
	else{
		while (heading > deg){
			wait1Msec(3);
		}
	}

	SetMotors(0,0);
}



task endgameAutoL(){
	moveStraight(-10);
	turnDegrees(90);
	moveStraight(30);
	turnDegrees(90);
	moveStraight(25);
	turnDegrees(-90);
	drivingOn = true;
}

task endgameAutoR(){
	moveStraight(-10);
	turnDegrees(-90);
	moveStraight(30);
	turnDegrees(-90);
	moveStraight(25);
	turnDegrees(90);
	drivingOn = true;
}

task stopEndgameAuto(){
	while (true){
		if(joy1Btn(joyStopEndgame)==1){
			StopTask(endgameAutoL);
			StopTask(endgameAutoR);
			SetMotors(0,0);
			motor[motorHang] = 0;
			drivingOn = true;
			break;
		}
		wait1Msec(100);
	}
}

void startEndGameAuto(int left, int right){
	if (left == 1){
		drivingOn = false;
		StartTask(stopEndgameAuto);
		StartTask(endgameAutoL);
	}
	else if (right ==1){
		drivingOn = false;
		StartTask(stopEndgameAuto);
		StartTask(endgameAutoR);
	}
}




task mainDriving(){
	while (true)
	{
		if (drivingOn){
			Tank(joystick.joy1_y1, joystick.joy1_y2);
			Flag(joy1Btn(joyFlagUp),joy1Btn(joyFlagDown));
			Block(joy1Btn(joyBlockUp), joy1Btn(joyBlockDown));
			startEndGameAuto(joy1Btn(joyStartEndgameL),joy1Btn(joyStartEndgameR));
		}
		Hang(joy1Btn(joyHangUp)||joy2Btn(joyHangUp), joy1Btn(joyHangDown)||joy2Btn(joyHangDown));
		wait1Msec(5);
	}
}





task main()
{
	nMotorEncoder[blockMotor] = 0;
	HTGYROstartCal(Gyro);

	wait10Msec(50);

	StartTask(updateGyro);
	StartTask(mainDriving);

	while(true){wait10Msec(99999999999999);}
}
